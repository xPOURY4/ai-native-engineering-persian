<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ساخت تیم مهندسی مبتنی بر هوش مصنوعی - OpenAI</title>
    <link href="https://cdn.jsdelivr.net/gh/rastikerdar/vazirmatn@v33.003/Vazirmatn-font-face.css" rel="stylesheet" type="text/css" />
    <style>
        :root {
            --primary-color: #000000;
            --accent-color: #10a37f; 
            --bg-color: #ffffff;
            --text-color: #2d2d2d;
            --light-gray: #f9f9f9;
            --border-color: #e5e5e5;
            --section-spacing: 80px;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Vazirmatn', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.8;
            font-size: 16px;
            overflow-x: hidden;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
        }

        a {
            color: var(--accent-color);
            text-decoration: none;
            font-weight: bold;
        }

        a:hover {
            text-decoration: underline;
        }

        /* Header & Images */
        header {
            margin-bottom: 60px;
            text-align: right;
            padding-top: 40px;
        }

        .brand {
            font-weight: 900;
            font-size: 1.6rem;
            margin-bottom: 40px;
            display: block;
        }

        h1 {
            font-size: 3rem;
            font-weight: 800;
            line-height: 1.3;
            margin-bottom: 20px;
            letter-spacing: -1px;
            color: #000;
        }

        .subtitle {
            font-size: 1.4rem;
            color: #555;
            margin-bottom: 40px;
        }

        .responsive-img {
            width: 100%;
            height: auto;
            border-radius: 12px;
            margin-bottom: 40px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        /* Typography */
        h2 {
            font-size: 2.2rem;
            margin-top: 60px;
            margin-bottom: 30px;
            position: relative;
            padding-bottom: 15px;
        }
        
        h2::after {
            content: '';
            position: absolute;
            bottom: 0;
            right: 0;
            width: 60px;
            height: 4px;
            background-color: var(--accent-color);
        }

        h3 {
            font-size: 1.6rem;
            margin-top: 40px;
            margin-bottom: 20px;
            color: #1a1a1a;
        }

        h4 {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 10px;
        }

        p {
            margin-bottom: 20px;
            text-align: justify;
            font-size: 1.05rem;
        }

        ul {
            list-style-type: disc;
            margin-right: 25px;
            margin-bottom: 20px;
        }

        li {
            margin-bottom: 10px;
        }

        /* Comparison Grid */
        .comparison-grid {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 20px;
            margin-bottom: 40px;
            border-top: 1px solid var(--border-color);
            padding-top: 20px;
        }

        .comparison-item {
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 20px;
        }
        
        .comparison-label {
            font-weight: 800;
            font-size: 1.1rem;
            color: #000;
        }

        /* Roles Grid (Delegate/Review/Own) */
        .roles-section {
            margin-top: 30px;
        }

        .role-row {
            display: grid;
            grid-template-columns: 120px 1fr;
            gap: 20px;
            margin-bottom: 20px;
            background: #fff;
            border-bottom: 1px solid #eee;
            padding-bottom: 20px;
        }

        .role-title {
            font-weight: 900;
            font-size: 1.1rem;
        }

        /* Checklists */
        .checklist {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 12px;
            padding: 30px;
            margin-top: 40px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .checklist-title {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 25px;
            color: #000;
        }

        .checklist-item {
            display: flex;
            align-items: flex-start;
            margin-bottom: 18px;
            cursor: pointer;
            transition: background 0.2s;
            padding: 5px;
            border-radius: 6px;
        }
        
        .checklist-item:hover {
            background: #f5f5f5;
        }

        .checkbox-circle {
            min-width: 24px;
            height: 24px;
            border: 2px solid #555;
            border-radius: 50%;
            margin-left: 15px;
            margin-top: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: white;
            transition: all 0.3s;
        }
        
        .checklist-item.checked .checkbox-circle {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
        }

        /* Example Box */
        .example-box {
            background-color: var(--light-gray);
            border: 1px solid #ddd;
            padding: 25px;
            border-radius: 8px;
            margin: 30px 0;
        }

        .example-label {
            font-weight: 900;
            display: block;
            margin-bottom: 10px;
            color: #000;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Footer */
        footer {
            margin-top: 100px;
            background: #f5f5f5;
            padding: 40px 20px;
            text-align: center;
            border-top: 1px solid #ddd;
        }
        
        .dev-signature {
            margin-top: 20px;
            font-family: monospace;
            color: #666;
            font-size: 0.9rem;
            direction: ltr;
        }

        /* Responsive */
        @media (max-width: 768px) {
            h1 { font-size: 2.2rem; }
            .comparison-grid { grid-template-columns: 1fr; }
            .role-row { grid-template-columns: 1fr; gap: 5px; }
            .role-title { color: var(--accent-color); margin-bottom: 5px; }
            .container { padding: 15px; }
        }
    </style>
</head>
<body>

<div class="container">

    <header>
        <span class="brand">OpenAI</span>
        <h1>ساخت تیم مهندسی<br>مبتنی بر هوش مصنوعی</h1>
        <p class="subtitle">چگونه عامل‌های کدنویسی (Coding Agents) چرخه حیات توسعه نرم‌افزار را شتاب می‌دهند</p>

        <img src="1.png" alt="کدنویسی انتزاعی با هوش مصنوعی" class="responsive-img">
    </header>

    <section id="intro">
        <h2>مقدمه</h2>
        <p>
            مدل‌های هوش مصنوعی به سرعت در حال گسترش دامنه وظایفی هستند که می‌توانند انجام دهند و این امر پیامدهای قابل توجهی برای مهندسی دارد. سیستم‌های پیشرو اکنون می‌توانند استدلال‌های چندساعته را حفظ کنند: طبق یافته‌های METR در اوت ۲۰۲۵، مدل‌های پیشرو می‌توانستند <strong>۲ ساعت و ۱۷ دقیقه</strong> کار مداوم را با حدود <strong>۵۰٪ اطمینان</strong> از تولید پاسخ صحیح تکمیل کنند.
        </p>
        <p>
            این توانایی به سرعت در حال بهبود است و طول انجام وظایف تقریباً هر هفت ماه دو برابر می‌شود. تنها چند سال پیش، مدل‌ها می‌توانستند حدود ۳۰ ثانیه استدلال را مدیریت کنند – که برای پیشنهادات کد کوچک کافی بود. امروز، همانطور که مدل‌ها زنجیره‌های طولانی‌تری از استدلال را حفظ می‌کنند، کل چرخه حیات توسعه نرم‌افزار (SDLC) به طور بالقوه در دامنه کمک هوش مصنوعی قرار می‌گیرد و به عامل‌های کدنویسی اجازه می‌دهد تا در برنامه‌ریزی، طراحی، توسعه، تست، بازبینی کد و استقرار مشارکت موثری داشته باشند.
        </p>

        <div style="margin: 40px 0;">
            <h4>افق زمانی وظایف مهندسی نرم‌افزار که LLMها می‌توانند انجام دهند</h4>
            <img src="2.png" alt="نمودار پیشرفت زمانی مدل‌های زبانی" class="responsive-img">
            <p style="font-size: 0.8rem; color: #666; text-align: center;">منبع: METR، اندازه‌گیری توانایی هوش مصنوعی در تکمیل وظایف طولانی</p>
        </div>

        <p>
            در این راهنما، ما نمونه‌های واقعی را به اشتراک می‌گذاریم که نشان می‌دهد چگونه عامل‌های هوش مصنوعی به چرخه حیات توسعه نرم‌افزار کمک می‌کنند، همراه با راهنمایی‌های عملی در مورد آنچه رهبران مهندسی می‌توانند امروز برای شروع ساخت تیم‌ها و فرآیندهای مبتنی بر هوش مصنوعی انجام دهند.
        </p>
    </section>

    <section id="evolution">
        <h2>کدنویسی با هوش مصنوعی: از تکمیل خودکار تا ایجنت‌ها</h2>
        <p>
            ابزارهای کدنویسی هوش مصنوعی بسیار فراتر از ریشه‌های خود به عنوان دستیاران تکمیل خودکار (Autocomplete) پیشرفت کرده‌اند. ابزارهای اولیه وظایف سریعی مانند پیشنهاد خط بعدی کد یا پر کردن قالب‌های توابع را انجام می‌دادند. با به دست آوردن توانایی‌های استدلال قوی‌تر، توسعه‌دهندگان تعامل با عامل‌ها را از طریق رابط‌های چت در IDE برای برنامه‌نویسی دونفره (Pair programming) و کاوش کد آغاز کردند.
        </p>
        <p>
            امروزه، عامل‌های کدنویسی می‌توانند فایل‌های کامل تولید کنند، پروژه‌های جدید را پایه‌ریزی کنند و طراحی‌ها را به کد تبدیل نمایند. آن‌ها می‌توانند مسائل چندمرحله‌ای مانند دیباگ کردن یا بازسازی کد (Refactoring) را استدلال کنند. اجرای عامل‌ها نیز اکنون از ماشین توسعه‌دهنده فردی به محیط‌های ابری و چند-عاملی تغییر یافته است. این امر نحوه کار توسعه‌دهندگان را تغییر می‌دهد و به آن‌ها اجازه می‌دهد زمان کمتری را صرف تولید کد با عامل در IDE و زمان بیشتری را صرف واگذاری کل گردش‌های کاری کنند.
        </p>

        <div class="comparison-grid">
            <div class="comparison-item comparison-label">پیشرفت</div>
            <div class="comparison-item comparison-label">چه چیزی را ممکن می‌سازد</div>

            <div class="comparison-item comparison-label">یکپارچگی زمینه (Context) در سراسر سیستم‌ها</div>
            <div class="comparison-item">
                یک مدل واحد می‌تواند کد، پیکربندی و تلمتری را بخواند و استدلالی منسجم در لایه‌هایی که قبلاً نیاز به ابزارهای جداگانه داشتند، ارائه دهد.
            </div>

            <div class="comparison-item comparison-label">اجرای ابزار ساختاریافته</div>
            <div class="comparison-item">
                مدل‌ها اکنون می‌توانند کامپایلرها، اجراکنندگان تست و اسکنرها را مستقیماً فراخوانی کنند و نتایج قابل تایید تولید کنند، نه فقط پیشنهادات ثابت.
            </div>

            <div class="comparison-item comparison-label">حافظه پایدار پروژه</div>
            <div class="comparison-item">
                پنجره‌های زمینه طولانی و تکنیک‌هایی مانند فشرده‌سازی به مدل‌ها اجازه می‌دهد ویژگی‌ها را از پیشنهاد تا استقرار دنبال کنند و انتخاب‌های طراحی و محدودیت‌های قبلی را به خاطر بسپارند.
            </div>

            <div class="comparison-item comparison-label">حلقه‌های ارزیابی</div>
            <div class="comparison-item">
                خروجی‌های مدل می‌توانند به‌طور خودکار در برابر معیارها (تست‌های واحد، اهداف تأخیر، یا راهنماهای سبک) آزمایش شوند، بنابراین پیشرفت‌ها بر اساس کیفیت قابل اندازه‌گیری استوار هستند.
            </div>
        </div>
    </section>

    <section id="openai-internal">
        <h2>تجربه داخلی OpenAI</h2>
        <p>
            در OpenAI، ما این موضوع را از نزدیک شاهد بوده‌ایم. چرخه‌های توسعه شتاب گرفته‌اند و کارهایی که زمانی هفته‌ها طول می‌کشید، اکنون در چند روز تحویل داده می‌شوند. تیم‌ها راحت‌تر بین دامنه‌ها حرکت می‌کنند، سریع‌تر با پروژه‌های ناآشنا آشنا می‌شوند (Onboarding) و با چابکی و استقلال بیشتری در سراسر سازمان فعالیت می‌کنند. بسیاری از وظایف روتین و وقت‌گیر، از مستندسازی کدهای جدید و یافتن تست‌های مرتبط گرفته تا نگهداری وابستگی‌ها و پاکسازی Feature Flagها، اکنون کاملاً به Codex واگذار می‌شوند.
        </p>
        <p>
            با این حال، برخی از جنبه‌های مهندسی بدون تغییر باقی مانده‌اند. مالکیت واقعی کد — به ویژه برای مسائل جدید یا مبهم — همچنان بر عهده مهندسان است و برخی چالش‌ها فراتر از توانایی‌های مدل‌های فعلی هستند. اما با وجود عامل‌های کدنویسی مانند Codex، مهندسان اکنون می‌توانند زمان بیشتری را صرف چالش‌های پیچیده و جدید کنند و به جای دیباگ کردن یا پیاده‌سازی‌های حفظی، بر طراحی، معماری و استدلال در سطح سیستم تمرکز کنند.
        </p>
        <p>
            در بخش‌های بعدی، ما بررسی می‌کنیم که چگونه هر مرحله از SDLC با عامل‌های کدنویسی تغییر می‌کند — و گام‌های مشخصی را که تیم شما می‌تواند برای شروع فعالیت به عنوان یک سازمان مهندسی بومی هوش مصنوعی (AI-native) بردارد، ترسیم می‌کنیم.
        </p>
    </section>

    <section id="plan">
        <h2>۱. برنامه‌ریزی (Plan)</h2>
        <p>
            تیم‌ها در سراسر سازمان اغلب برای تعیین امکان‌سنجی یک ویژگی، زمان لازم برای ساخت آن و سیستم‌ها یا تیم‌های درگیر، به مهندسان وابسته هستند. در حالی که هر کسی می‌تواند یک مشخصات (Spec) پیش‌نویس کند، تشکیل یک برنامه دقیق معمولاً نیاز به آگاهی عمیق از پایگاه کد و چندین دور تکرار با مهندسی برای کشف نیازمندی‌ها، شفاف‌سازی حالت‌های لبه و همسویی در مورد آنچه از نظر فنی واقع‌بینانه است، دارد.
        </p>
        
        <h3>چگونه عامل‌های کدنویسی کمک می‌کنند</h3>
        <p>
            عامل‌های هوش مصنوعی بینش‌های فوری و آگاه به کد را در طول برنامه‌ریزی و تعیین محدوده ارائه می‌دهند. برای مثال، تیم‌ها ممکن است گردش‌کارهایی بسازند که عامل‌های کدنویسی را به سیستم‌های ردیابی مسئله (Issue Tracking) متصل کند تا مشخصات ویژگی را بخوانند، آن را با پایگاه کد تطبیق دهند و سپس ابهامات را علامت‌گذاری کنند، کار را به اجزای فرعی بشکنند یا سختی آن را تخمین بزنند.
        </p>
        <p>
            عامل‌های کدنویسی همچنین می‌توانند فوراً مسیرهای کد را ردیابی کنند تا نشان دهند کدام سرویس‌ها در یک ویژگی درگیر هستند — کاری که قبلاً نیاز به ساعت‌ها یا روزها جستجوی دستی در پایگاه کد بزرگ داشت.
        </p>

        <h3>مهندسان به جای آن چه می‌کنند</h3>
        <p>
            تیم‌ها زمان بیشتری را صرف کار روی ویژگی اصلی می‌کنند زیرا عامل‌ها زمینه‌ای را فراهم می‌کنند که قبلاً نیاز به جلسات برای همسویی محصول و تعیین محدوده داشت. جزئیات کلیدی پیاده‌سازی، وابستگی‌ها و حالت‌های لبه از همان ابتدا شناسایی می‌شوند که امکان تصمیم‌گیری سریع‌تر با جلسات کمتر را فراهم می‌کند.
        </p>

        <div class="roles-section">
            <div class="role-row">
                <div class="role-title">واگذاری (Delegate)</div>
                <div>عامل‌های هوش مصنوعی می‌توانند اولین پاس تحلیل امکان‌سنجی و معماری را انجام دهند. آن‌ها مشخصات را می‌خوانند، آن را به پایگاه کد نگاشت می‌کنند، وابستگی‌ها را شناسایی کرده و ابهامات یا حالت‌های لبه‌ای که نیاز به شفاف‌سازی دارند را مشخص می‌کنند.</div>
            </div>
            <div class="role-row">
                <div class="role-title">بازبینی (Review)</div>
                <div>تیم‌ها یافته‌های عامل را برای اعتبارسنجی دقت، ارزیابی کامل بودن و اطمینان از اینکه تخمین‌ها منعکس‌کننده محدودیت‌های فنی واقعی هستند، بررسی می‌کنند. تخصیص امتیاز داستان (Story point)، اندازه‌گیری تلاش و شناسایی ریسک‌های غیرآشکار هنوز نیاز به قضاوت انسانی دارد.</div>
            </div>
            <div class="role-row">
                <div class="role-title">مالکیت (Own)</div>
                <div>تصمیمات استراتژیک — مانند اولویت‌بندی، جهت‌گیری بلندمدت، توالی و بده‌بستان‌ها (Tradeoffs) — توسط انسان رهبری می‌شود. تیم‌ها ممکن است از عامل گزینه‌ها یا گام‌های بعدی را بپرسند، اما مسئولیت نهایی برنامه‌ریزی و جهت محصول با سازمان باقی می‌ماند.</div>
            </div>
        </div>

        <div class="checklist">
            <div class="checklist-title">چک‌لیست شروع کار</div>
            <div class="checklist-item">
                <div class="checkbox-circle"></div>
                <div>شناسایی فرآیندهای رایجی که نیاز به هماهنگی بین ویژگی‌ها و کد منبع دارند. حوزه‌های رایج شامل محدوده‌بندی ویژگی و ایجاد تیکت است.</div>
            </div>
            <div class="checklist-item">
                <div class="checkbox-circle"></div>
                <div>شروع با پیاده‌سازی گردش‌کارهای پایه، برای مثال برچسب‌گذاری و حذف موارد تکراری یا درخواست‌های ویژگی.</div>
            </div>
            <div class="checklist-item">
                <div class="checkbox-circle"></div>
                <div>در نظر گرفتن گردش‌کارهای پیشرفته‌تر، مانند افزودن زیر-وظایف به یک تیکت بر اساس توضیحات اولیه ویژگی. یا شروع اجرای عامل زمانی که تیکت به مرحله خاصی می‌رسد تا توضیحات را با جزئیات بیشتر تکمیل کند.</div>
            </div>
        </div>
    </section>

    <section id="design">
        <h2>۲. طراحی (Design)</h2>
        <p>
            مرحله طراحی اغلب با کارهای راه‌اندازی اولیه (Setup) کند می‌شود. تیم‌ها زمان قابل توجهی را صرف اتصال کدهای کلیشه‌ای (Boilerplate)، یکپارچه‌سازی سیستم‌های طراحی و اصلاح اجزای UI یا جریان‌ها می‌کنند. عدم همسویی بین موکاپ‌ها و پیاده‌سازی می‌تواند باعث دوباره‌کاری و چرخه‌های بازخورد طولانی شود، و محدودیت پهنای باند برای کاوش جایگزین‌ها یا انطباق با تغییر نیازمندی‌ها، اعتبارسنجی طراحی را به تأخیر می‌اندازد.
        </p>

        <h3>چگونه عامل‌های کدنویسی کمک می‌کنند</h3>
        <p>
            ابزارهای کدنویسی هوش مصنوعی با ایجاد کدهای کلیشه‌ای، ساخت ساختارهای پروژه و پیاده‌سازی فوری توکن‌های طراحی یا راهنماهای سبک، نمونه‌سازی اولیه (Prototyping) را به طرز چشمگیری تسریع می‌کنند. مهندسان می‌توانند ویژگی‌های مورد نظر یا طرح‌بندی UI را به زبان طبیعی توصیف کنند و کدهای نمونه یا استاب‌های کامپوننت دریافت کنند که با قراردادهای تیم مطابقت دارد.
        </p>
        <p>
            آن‌ها می‌توانند طرح‌ها را مستقیماً به کد تبدیل کنند، بهبودهای دسترسی‌پذیری را پیشنهاد دهند و حتی پایگاه کد را برای جریان‌های کاربر یا حالت‌های لبه تحلیل کنند. این امکان را فراهم می‌کند که به جای روزها، در ساعت‌ها روی چندین پروتوتایپ تکرار انجام شود و نمونه‌سازی با وفاداری بالا (High fidelity) زودتر انجام شود که مبنای روشن‌تری برای تصمیم‌گیری و تست مشتری فراهم می‌کند.
        </p>

        <h3>مهندسان به جای آن چه می‌کنند</h3>
        <p>
            با انجام وظایف روتین راه‌اندازی و ترجمه توسط عامل‌ها، تیم‌ها می‌توانند توجه خود را به کارهای با اهرم بالاتر معطوف کنند. مهندسان بر پالایش منطق هسته، ایجاد الگوهای معماری مقیاس‌پذیر و اطمینان از کیفیت و قابلیت اطمینان اجزا تمرکز می‌کنند. طراحان می‌توانند زمان بیشتری را صرف ارزیابی جریان‌های کاربر و کاوش مفاهیم جایگزین کنند. تلاش مشترک از سربار پیاده‌سازی به بهبود تجربه محصول زیربنایی تغییر می‌کند.
        </p>

        <div class="roles-section">
            <div class="role-row">
                <div class="role-title">واگذاری (Delegate)</div>
                <div>عامل‌ها کارهای اولیه پیاده‌سازی مانند ساختاردهی پروژه، تولید کدهای Boilerplate، ترجمه موکاپ‌ها به کامپوننت‌ها و اعمال توکن‌های طراحی یا راهنماهای سبک را انجام می‌دهند.</div>
            </div>
            <div class="role-row">
                <div class="role-title">بازبینی (Review)</div>
                <div>تیم خروجی عامل را بررسی می‌کند تا اطمینان حاصل شود که کامپوننت‌ها از قراردادهای طراحی پیروی می‌کنند، استانداردهای کیفیت و دسترسی‌پذیری را رعایت می‌کنند و به درستی با سیستم‌های موجود ادغام می‌شوند.</div>
            </div>
            <div class="role-row">
                <div class="role-title">مالکیت (Own)</div>
                <div>تیم مالکیت سیستم طراحی کلان، الگوهای تجربه کاربری (UX)، تصمیمات معماری و جهت نهایی تجربه کاربر را حفظ می‌کند.</div>
            </div>
        </div>

        <div class="checklist">
            <div class="checklist-title">چک‌لیست شروع کار</div>
            <div class="checklist-item">
                <div class="checkbox-circle"></div>
                <div>استفاده از یک عامل کدنویسی چند-وجهی (Multi-modal) که هم ورودی متن و هم تصویر را می‌پذیرد.</div>
            </div>
            <div class="checklist-item">
                <div class="checkbox-circle"></div>
                <div>یکپارچه‌سازی ابزارهای طراحی از طریق MCP با عامل‌های کدنویسی.</div>
            </div>
            <div class="checklist-item">
                <div class="checkbox-circle"></div>
                <div>نمایش برنامه‌نویسی کتابخانه‌های کامپوننت با MCP و ادغام آن‌ها با مدل کدنویسی خود.</div>
            </div>
            <div class="checklist-item">
                <div class="checkbox-circle"></div>
                <div>ساخت گردش‌کارهایی که "طرح‌ها ← کامپوننت‌ها ← پیاده‌سازی کامپوننت‌ها" را نقشه‌برداری می‌کنند.</div>
            </div>
            <div class="checklist-item">
                <div class="checkbox-circle"></div>
                <div>استفاده از زبان‌های نوع‌دار (مانند Typescript) برای تعریف پراپ‌ها و زیر-اجزای معتبر برای عامل.</div>
            </div>
        </div>
    </section>

    <section id="build">
        <h2>۳. ساخت (Build)</h2>
        <p>
            مرحله ساخت جایی است که تیم‌ها بیشترین اصطکاک را احساس می‌کنند و جایی است که عامل‌های کدنویسی واضح‌ترین تأثیر را دارند. مهندسان زمان قابل توجهی را صرف ترجمه مشخصات به ساختارهای کد، اتصال سرویس‌ها به یکدیگر، تکرار الگوها در سراسر پایگاه کد و پر کردن کدهای کلیشه‌ای می‌کنند، به طوری که حتی ویژگی‌های کوچک نیاز به ساعت‌ها کار شلوغ (Busy-work) دارد.
        </p>
        <p>
            با رشد سیستم‌ها، این اصطکاک ترکیب می‌شود. مخازن بزرگ (Monorepos) الگوها، قراردادها و ویژگی‌های تاریخی را جمع می‌کنند که مشارکت‌کنندگان را کند می‌کند. مهندسان ممکن است به اندازه زمان پیاده‌سازی ویژگی، زمان صرف کشف "راه درست" انجام کار کنند. تغییر مداوم زمینه بین مشخصات، جستجوی کد، خطاهای بیلد، شکست تست و مدیریت وابستگی، بار شناختی را افزایش می‌دهد.
        </p>

        <h3>چگونه عامل‌های کدنویسی کمک می‌کنند</h3>
        <p>
            عامل‌های کدنویسی که در IDE و CLI اجرا می‌شوند، با انجام وظایف پیاده‌سازی بزرگتر و چندمرحله‌ای، فاز ساخت را تسریع می‌کنند. به جای تولید فقط تابع یا فایل بعدی، آن‌ها می‌توانند ویژگی‌های کامل را از ابتدا تا انتها (end-to-end) — شامل مدل‌های داده، APIها، کامپوننت‌های UI، تست‌ها و مستندات — در یک اجرای هماهنگ تولید کنند. با استدلال پایدار در کل پایگاه کد، آن‌ها تصمیماتی را مدیریت می‌کنند که زمانی نیاز به ردیابی دستی مسیرهای کد توسط مهندسان داشت.
        </p>
        
        <ul style="background: #fdfdfd; padding: 20px; border-right: 4px solid var(--accent-color);">
            <li>پیش‌نویس پیاده‌سازی کامل ویژگی‌ها بر اساس مشخصات مکتوب.</li>
            <li>جستجو و اصلاح کد در ده‌ها فایل ضمن حفظ ثبات.</li>
            <li>تولید کدهای Boilerplate که با قراردادها مطابقت دارد: مدیریت خطا، تلمتری، پوشش‌های امنیتی یا الگوهای سبک.</li>
            <li>رفع خطاهای بیلد به محض ظهور به جای توقف برای مداخله انسانی.</li>
            <li>نوشتن تست‌ها در کنار پیاده‌سازی به عنوان بخشی از یک گردش کار واحد.</li>
            <li>تولید تغییرات آماده تفاوت (Diff-ready) که از دستورالعمل‌های داخلی پیروی می‌کنند و شامل پیام‌های PR هستند.</li>
        </ul>

        <h3>مهندسان به جای آن چه می‌کنند</h3>
        <p>
            وقتی عامل‌ها می‌توانند وظایف ساخت چندمرحله‌ای را با اطمینان انجام دهند، مهندسان توجه خود را به کار با نظم بالاتر تغییر می‌دهند:
            <br>- شفاف‌سازی رفتار محصول، حالت‌های لبه و مشخصات قبل از پیاده‌سازی.
            <br>- بررسی پیامدهای معماری کد تولید شده توسط هوش مصنوعی به جای انجام سیم‌کشی‌های حفظی.
            <br>- پالایش منطق تجاری و مسیرهای حیاتی عملکرد که نیاز به استدلال عمیق دامنه دارند.
            <br>- طراحی الگوها، گاردریل‌ها و قراردادهایی که کد تولید شده توسط عامل را هدایت می‌کنند.
        </p>

        <div class="roles-section">
            <div class="role-row">
                <div class="role-title">واگذاری (Delegate)</div>
                <div>عامل‌ها اولین پاس پیاده‌سازی را برای ویژگی‌های کاملاً مشخص پیش‌نویس می‌کنند — داربست‌بندی، منطق CRUD، سیم‌کشی، بازسازی و تست‌ها. با بهبود استدلال طولانی‌مدت، این به طور فزاینده‌ای ساخت‌های کامل پایان-به-پایان را پوشش می‌دهد.</div>
            </div>
            <div class="role-row">
                <div class="role-title">بازبینی (Review)</div>
                <div>مهندسان انتخاب‌های طراحی، عملکرد، امنیت، ریسک مهاجرت و همسویی دامنه را ارزیابی می‌کنند در حالی که مسائل ظریفی را که عامل ممکن است از دست بدهد اصلاح می‌کنند. آن‌ها کد تولید شده توسط هوش مصنوعی را شکل می‌دهند و اصلاح می‌کنند.</div>
            </div>
            <div class="role-row">
                <div class="role-title">مالکیت (Own)</div>
                <div>مهندسان مالکیت کارهایی را که نیاز به شهود سیستم عمیق دارد حفظ می‌کنند: انتزاعات جدید، تغییرات معماری متقاطع، نیازمندی‌های محصول مبهم و بده‌بستان‌های نگهداری طولانی‌مدت.</div>
            </div>
        </div>

        <div class="example-box">
            <span class="example-label">مثال</span>
            <p>
                مهندسان، مدیران محصول، طراحان و اپراتورها در <strong>Cloudwalk</strong> روزانه از Codex استفاده می‌کنند تا مشخصات را به کد کارآمد تبدیل کنند، چه نیاز به یک اسکریپت باشد، چه قانون جدید تقلب، یا یک میکروسرویس کامل که در عرض چند دقیقه تحویل داده می‌شود. این کار، شلوغ‌کاری را از فاز ساخت حذف می‌کند و به هر کارمند قدرت می‌دهد تا ایده‌ها را با سرعتی قابل توجه پیاده‌سازی کند.
            </p>
        </div>

        <div class="checklist">
            <div class="checklist-title">چک‌لیست شروع کار</div>
            <div class="checklist-item">
                <div class="checkbox-circle"></div>
                <div>شروع با وظایف کاملاً مشخص (Well specified tasks).</div>
            </div>
            <div class="checklist-item">
                <div class="checkbox-circle"></div>
                <div>واداشتن عامل به استفاده از ابزار برنامه‌ریزی از طریق MCP، یا با نوشتن فایل PLAN.md که در پایگاه کد commit می‌شود.</div>
            </div>
            <div class="checklist-item">
                <div class="checkbox-circle"></div>
                <div>بررسی اینکه دستوراتی که عامل تلاش می‌کند اجرا کند موفقیت‌آمیز هستند.</div>
            </div>
            <div class="checklist-item">
                <div class="checkbox-circle"></div>
                <div>تکرار روی فایل AGENTS.md که حلقه‌های عاملی مانند اجرای تست‌ها و لینترها برای دریافت بازخورد را باز می‌کند.</div>
            </div>
        </div>
    </section>
    <section id="test">
        <h2>۴. تست (Test)</h2>
        <p>
            توسعه‌دهندگان اغلب در تضمین پوشش تست کافی مشکل دارند زیرا نوشتن و نگهداری تست‌های جامع زمان‌بر است، نیاز به تغییر زمینه دارد و مستلزم درک عمیق حالت‌های لبه است. تیم‌ها اغلب با بده‌بستان‌هایی بین حرکت سریع و نوشتن تست‌های کامل مواجه هستند. وقتی ضرب‌الاجل‌ها نزدیک می‌شوند، پوشش تست اغلب اولین چیزی است که آسیب می‌بیند.
        </p>
        <p>
            حتی زمانی که تست‌ها نوشته می‌شوند، به‌روز نگه داشتن آن‌ها با تکامل کد اصطکاک مداوم ایجاد می‌کند. تست‌ها می‌توانند شکننده شوند، به دلایل نامشخص شکست بخورند و ممکن است نیاز به بازسازی‌های عمده خود داشته باشند. تست‌های با کیفیت بالا به تیم‌ها اجازه می‌دهند سریع‌تر و با اطمینان بیشتر شیپ کنند.
        </p>

        <h3>چگونه عامل‌های کدنویسی کمک می‌کنند</h3>
        <p>
            ابزارهای کدنویسی هوش مصنوعی می‌توانند به توسعه‌دهندگان کمک کنند تا تست‌های بهتری را به چندین روش قدرتمند بنویسند. اول، آن‌ها می‌توانند موارد تست (Test cases) را بر اساس خواندن سند نیازمندی‌ها و منطق کد ویژگی پیشنهاد دهند. مدل‌ها به طرز شگفت‌آوری در پیشنهاد حالت‌های لبه و حالت‌های شکست که ممکن است نادیده گرفتن آن‌ها برای توسعه‌دهنده آسان باشد، خوب عمل می‌کنند.
        </p>
        <p>
            علاوه بر این، مدل‌ها می‌توانند به به‌روز نگه داشتن تست‌ها با تکامل کد کمک کنند و اصطکاک بازسازی و اجتناب از تست‌های قدیمی که شکننده (Flaky) می‌شوند را کاهش دهند.
        </p>

        <h3>مهندسان به جای آن چه می‌کنند</h3>
        <p>
            نوشتن تست با ابزارهای هوش مصنوعی نیاز توسعه‌دهندگان به فکر کردن درباره تست را از بین نمی‌برد. در واقع، همانطور که عامل‌ها موانع تولید کد را برطرف می‌کنند، تست‌ها عملکرد مهم و مهم‌تری به عنوان منبع حقیقت برای عملکرد برنامه پیدا می‌کنند. از آنجا که عامل‌ها می‌توانند مجموعه تست را اجرا کنند و بر اساس خروجی تکرار کنند، تعریف تست‌های با کیفیت بالا اغلب اولین گام برای اجازه دادن به یک عامل برای ساخت یک ویژگی است.
        </p>
        <p>
            در عوض، توسعه‌دهندگان بیشتر بر روی دیدن الگوهای سطح بالا در پوشش تست، ساختن و به چالش کشیدن شناسایی موارد تست توسط مدل تمرکز می‌کنند.
        </p>

        <div class="roles-section">
            <div class="role-row">
                <div class="role-title">واگذاری (Delegate)</div>
                <div>مهندسان پاس اولیه تولید موارد تست بر اساس مشخصات ویژگی را واگذار می‌کنند. آن‌ها همچنین از مدل برای گرفتن اولین پاس در تولید تست‌ها استفاده می‌کنند. مفید است که مدل تست‌ها را در جلسه‌ای جداگانه از پیاده‌سازی ویژگی تولید کند.</div>
            </div>
            <div class="role-row">
                <div class="role-title">بازبینی (Review)</div>
                <div>مهندسان باید همچنان تست‌های تولید شده توسط مدل را به دقت بررسی کنند تا اطمینان حاصل شود که مدل میانبر نزده یا تست‌های صوری (Stubbed) ایجاد نکرده است. مهندسان همچنین اطمینان حاصل می‌کنند که تست‌ها توسط عامل‌ها قابل اجرا هستند.</div>
            </div>
            <div class="role-row">
                <div class="role-title">مالکیت (Own)</div>
                <div>مهندسان مالک همسویی پوشش تست با مشخصات ویژگی و انتظارات تجربه کاربر هستند. تفکر خصمانه، خلاقیت در نگاشت حالت‌های لبه و تمرکز بر هدف تست‌ها مهارت‌های حیاتی باقی می‌مانند.</div>
            </div>
        </div>

        <div class="checklist">
            <div class="checklist-title">چک‌لیست شروع کار</div>
            <div class="checklist-item">
                <div class="checkbox-circle"></div>
                <div>راهنمایی مدل برای پیاده‌سازی تست‌ها به عنوان یک گام جداگانه، و اعتبارسنجی اینکه تست‌های جدید قبل از رفتن به پیاده‌سازی ویژگی شکست می‌خورند (Fail first).</div>
            </div>
            <div class="checklist-item">
                <div class="checkbox-circle"></div>
                <div>تنظیم دستورالعمل‌ها برای پوشش تست در فایل AGENTS.md خود.</div>
            </div>
            <div class="checklist-item">
                <div class="checkbox-circle"></div>
                <div>دادن مثال‌های خاص به عامل از ابزارهای پوشش کد (Code coverage) که می‌تواند فراخوانی کند تا پوشش تست را درک کند.</div>
            </div>
        </div>
    </section>
    <section id="review">
        <h2>۵. بازبینی (Review)</h2>
        <p>
            به طور متوسط، توسعه‌دهندگان ۲ تا ۵ ساعت در هفته را صرف بازبینی کد (Code review) می‌کنند. تیم‌ها اغلب با انتخابی بین سرمایه‌گذاری زمان قابل توجه در یک بازبینی عمیق یا انجام یک پاس سریع "به اندازه کافی خوب" برای تغییراتی که کوچک به نظر می‌رسند، مواجه هستند. وقتی این اولویت‌بندی نادرست باشد، باگ‌ها به تولید نشت می‌کنند و باعث ایجاد مسائل برای کاربران و دوباره‌کاری اساسی می‌شوند.
        </p>

        <h3>چگونه عامل‌های کدنویسی کمک می‌کنند</h3>
        <p>
            عامل‌های کدنویسی اجازه می‌دهند فرآیند بازبینی کد مقیاس‌پذیر شود، بنابراین هر PR یک خط پایه ثابت از توجه دریافت می‌کند. برخلاف ابزارهای تحلیل استاتیک سنتی (که بر تطبیق الگو و بررسی‌های مبتنی بر قانون متکی هستند) بازبین‌های هوش مصنوعی می‌توانند واقعاً بخش‌هایی از کد را اجرا کنند، رفتار زمان اجرا را تفسیر کنند و منطق را در فایل‌ها و سرویس‌ها ردیابی کنند.
        </p>

        <h3>مهندسان به جای آن چه می‌کنند</h3>
        <p>
            در OpenAI، ما دریافتیم که بازبینی کد با هوش مصنوعی به مهندسان اطمینان بیشتری می‌دهد که باگ‌های بزرگ را به تولید نمی‌فرستند. اغلب، بازبینی کد مسائلی را می‌گیرد که مشارکت‌کننده می‌تواند قبل از درگیر کردن مهندس دیگر اصلاح کند.
        </p>
        <p>
            <strong>واگذاری در مقابل بازبینی در مقابل مالکیت:</strong> حتی با بازبینی کد هوش مصنوعی، مهندسان همچنان مسئول اطمینان از آماده بودن کد برای ارسال (Ship) هستند. عملاً، این به معنای خواندن و درک پیامدهای تغییر است. مهندسان بازبینی کد اولیه را به یک عامل واگذار می‌کنند، اما مالک بازبینی نهایی و فرآیند ادغام (Merge) هستند.
        </p>

        <div class="roles-section">
            <div class="role-row">
                <div class="role-title">واگذاری (Delegate)</div>
                <div>مهندسان بازبینی کد اولیه را به عامل‌ها واگذار می‌کنند. این ممکن است چندین بار قبل از اینکه درخواست کشش (Pull request) به عنوان آماده برای بازبینی توسط هم‌تیمی علامت‌گذاری شود، اتفاق بیفتد.</div>
            </div>
            <div class="role-row">
                <div class="role-title">بازبینی (Review)</div>
                <div>مهندسان هنوز درخواست‌های کشش را بررسی می‌کنند، اما با تأکید بیشتر بر همسویی معماری؛ آیا الگوهای ترکیبی پیاده‌سازی می‌شوند، آیا قراردادهای صحیح استفاده می‌شوند، آیا عملکرد با نیازمندی‌ها مطابقت دارد.</div>
            </div>
            <div class="role-row">
                <div class="role-title">مالکیت (Own)</div>
                <div>مهندسان در نهایت مالک کدی هستند که به تولید مستقر می‌شود؛ آن‌ها باید اطمینان حاصل کنند که به طور قابل اعتماد عمل می‌کند و نیازمندی‌های مورد نظر را برآورده می‌کند.</div>
            </div>
        </div>

        <div class="example-box">
            <span class="example-label">مثال</span>
            <p>
                شرکت <strong>Sansan</strong> از بازبینی Codex برای شناسایی شرایط مسابقه (Race conditions) و روابط پایگاه داده استفاده می‌کند، مسائلی که انسان‌ها اغلب نادیده می‌گیرند. Codex همچنین توانسته است هاردکد کردن نامناسب را بگیرد و حتی نگرانی‌های مقیاس‌پذیری آینده را پیش‌بینی کند.
            </p>
        </div>

        <div class="checklist">
            <div class="checklist-title">چک‌لیست شروع کار</div>
            <div class="checklist-item">
                <div class="checkbox-circle"></div>
                <div>جمع‌آوری نمونه‌هایی از PRهای استاندارد طلایی که توسط مهندسان انجام شده است شامل تغییرات کد و نظرات گذاشته شده. ذخیره این به عنوان یک مجموعه ارزیابی.</div>
            </div>
            <div class="checklist-item">
                <div class="checkbox-circle"></div>
                <div>انتخاب محصولی که مدلی دارد که به طور خاص برای بازبینی کد آموزش دیده است. ما دریافتیم که مدل‌های عمومی اغلب ایرادگیر (Nitpick) هستند و نسبت سیگنال به نویز پایینی ارائه می‌دهند.</div>
            </div>
            <div class="checklist-item">
                <div class="checkbox-circle"></div>
                <div>تعریف اینکه تیم شما چگونه کیفیت بازبینی‌ها را اندازه‌گیری می‌کند. ما ردیابی واکنش‌ها (Reaction) به نظرات PR را به عنوان راهی کم‌اصطکاک برای علامت‌گذاری بازبینی‌های خوب و بد توصیه می‌کنیم.</div>
            </div>
            <div class="checklist-item">
                <div class="checkbox-circle"></div>
                <div>شروع کوچک اما گسترش سریع پس از کسب اطمینان از نتایج بازبینی‌ها.</div>
            </div>
        </div>
    </section>
    <section id="document">
        <h2>۶. مستندسازی (Document)</h2>
        <p>
            اکثر تیم‌های مهندسی می‌دانند که مستنداتشان عقب است، اما جبران آن را پرهزینه می‌دانند. دانش حیاتی اغلب توسط افراد نگهداری می‌شود تا در پایگاه‌های دانش قابل جستجو ثبت شود، و مستندات موجود به سرعت بیات می‌شوند زیرا به‌روزرسانی آن‌ها مهندسان را از کار محصول دور می‌کند.
        </p>

        <h3>چگونه عامل‌های کدنویسی کمک می‌کنند</h3>
        <p>
            عامل‌های کدنویسی توانایی بالایی در خلاصه‌سازی عملکرد بر اساس خواندن پایگاه کد دارند. نه تنها آن‌ها می‌توانند در مورد نحوه کار بخش‌های پایگاه کد بنویسند، بلکه می‌توانند نمودارهای سیستم را در سینتکس‌هایی مانند mermaid تولید کنند. همانطور که توسعه‌دهندگان ویژگی‌ها را با عامل‌ها می‌سازند، می‌توانند مستندات را نیز به سادگی با پرامپت دادن به مدل به‌روز کنند. با <code>AGENTS.md</code>، دستورالعمل‌های به‌روزرسانی مستندات در صورت نیاز می‌تواند به طور خودکار با هر پرامپت برای ثبات بیشتر گنجانده شود.
        </p>
        <p>
            از آنجا که عامل‌های کدنویسی می‌توانند به صورت برنامه‌نویسی از طریق SDKها اجرا شوند، می‌توانند در گردش‌کارهای انتشار (Release workflows) نیز گنجانده شوند. نتیجه این است که مستندسازی به بخشی داخلی از خط لوله تحویل تبدیل می‌شود: تولید سریع‌تر، نگهداری آسان‌تر و دیگر وابسته به "پیدا کردن وقت" توسط کسی نیست.
        </p>

        <h3>مهندسان به جای آن چه می‌کنند</h3>
        <p>
            مهندسان از نوشتن هر سند با دست به شکل‌دهی و نظارت بر سیستم تغییر مکان می‌دهند. آن‌ها تصمیم می‌گیرند که اسناد چگونه سازماندهی شوند، "چرا"ی مهم پشت تصمیمات را اضافه می‌کنند، استانداردها و قالب‌های روشنی را برای پیروی عامل‌ها تعیین می‌کنند و قطعات حیاتی یا رو به مشتری را بررسی می‌کنند.
        </p>

        <div class="roles-section">
            <div class="role-row">
                <div class="role-title">واگذاری (Delegate)</div>
                <div>واگذاری کامل کارهای کم‌ریسک و تکراری به Codex مانند خلاصه‌سازی‌های پاس اول فایل‌ها و ماژول‌ها، توضیحات اساسی ورودی‌ها و خروجی‌ها، لیست‌های وابستگی و خلاصه‌های کوتاه تغییرات درخواست کشش.</div>
            </div>
            <div class="role-row">
                <div class="role-title">بازبینی (Review)</div>
                <div>مهندسان اسناد مهمی را که توسط Codex پیش‌نویس شده‌اند مانند بررسی اجمالی خدمات اصلی، اسناد API عمومی و SDK، دستورالعمل‌های اجرایی (Runbooks) و صفحات معماری را قبل از انتشار بررسی و ویرایش می‌کنند.</div>
            </div>
            <div class="role-row">
                <div class="role-title">مالکیت (Own)</div>
                <div>مهندسان مسئول استراتژی کلی و ساختار مستندسازی، استانداردها و قالب‌هایی که عامل دنبال می‌کند، و تمام مستندات رو به خارج یا حیاتی ایمنی که شامل ریسک قانونی، نظارتی یا برند است، باقی می‌مانند.</div>
            </div>
        </div>

        <div class="checklist">
            <div class="checklist-title">چک‌لیست شروع کار</div>
            <div class="checklist-item">
                <div class="checkbox-circle"></div>
                <div>آزمایش تولید مستندات با پرامپت دادن به عامل کدنویسی.</div>
            </div>
            <div class="checklist-item">
                <div class="checkbox-circle"></div>
                <div>گنجاندن دستورالعمل‌های مستندسازی در فایل AGENTS.md خود.</div>
            </div>
            <div class="checklist-item">
                <div class="checkbox-circle"></div>
                <div>شناسایی گردش‌کارها (مانند چرخه‌های انتشار) که در آن‌ها مستندات می‌تواند به طور خودکار تولید شود.</div>
            </div>
            <div class="checklist-item">
                <div class="checkbox-circle"></div>
                <div>بررسی محتوای تولید شده برای کیفیت، صحت و تمرکز.</div>
            </div>
        </div>
    </section>

    <section id="deploy">
        <h2>۷. استقرار و نگهداری (Deploy & Maintain)</h2>
        <p>
            درک لاگ‌های برنامه برای قابلیت اطمینان نرم‌افزار حیاتی است. در طول یک حادثه (Incident)، مهندسان نرم‌افزار به ابزارهای لاگینگ، استقرار کد و تغییرات زیرساخت ارجاع می‌دهند تا علت ریشه‌ای را شناسایی کنند. این فرآیند اغلب به طرز شگفت‌آوری دستی است و نیاز دارد توسعه‌دهندگان بین سیستم‌های مختلف جابجا شوند که در موقعیت‌های پرفشار دقایق حیاتی را هدر می‌دهد.
        </p>

        <h3>چگونه عامل‌های کدنویسی کمک می‌کنند</h3>
        <p>
            با ابزارهای کدنویسی هوش مصنوعی، می‌توانید دسترسی به ابزارهای لاگینگ خود را از طریق سرورهای MCP علاوه بر زمینه پایگاه کد خود فراهم کنید. این به توسعه‌دهندگان اجازه می‌دهد تا یک گردش‌کار واحد داشته باشند که در آن می‌توانند از مدل بخواهند خطاهای یک نقطه پایانی (Endpoint) خاص را بررسی کند و سپس مدل می‌تواند از آن زمینه برای پیمایش پایگاه کد و یافتن باگ‌های مرتبط یا مسائل عملکرد استفاده کند.
        </p>

        <h3>مهندسان به جای آن چه می‌کنند</h3>
        <p>
            با خودکارسازی جنبه‌های خسته‌کننده تحلیل لاگ و تریاژ حوادث، هوش مصنوعی به مهندسان امکان می‌دهد تا بر عیب‌یابی سطح بالا و بهبود سیستم تمرکز کنند. به جای ارتباط دستی لاگ‌ها، کامیت‌ها و تغییرات زیرساخت، مهندسان می‌توانند بر اعتبارسنجی علل ریشه‌ای تولید شده توسط هوش مصنوعی، طراحی اصلاحات مقاوم و توسعه اقدامات پیشگیرانه تمرکز کنند.
        </p>

        <div class="roles-section">
            <div class="role-row">
                <div class="role-title">واگذاری (Delegate)</div>
                <div>بسیاری از وظایف عملیاتی را می‌توان به عامل‌ها واگذار کرد — پارس کردن لاگ‌ها، نشان دادن معیارهای غیرعادی، شناسایی تغییرات کد مشکوک و حتی پیشنهاد اصلاحات فوری (Hotfixes).</div>
            </div>
            <div class="role-row">
                <div class="role-title">بازبینی (Review)</div>
                <div>مهندسان تشخیص‌های تولید شده توسط هوش مصنوعی را بررسی و اصلاح می‌کنند، دقت را تأیید می‌کنند و مراحل اصلاح را تأیید می‌کنند. آن‌ها اطمینان حاصل می‌کنند که اصلاحات استانداردهای قابلیت اطمینان، امنیت و انطباق را رعایت می‌کنند.</div>
            </div>
            <div class="role-row">
                <div class="role-title">مالکیت (Own)</div>
                <div>تصمیمات حیاتی با مهندسان باقی می‌ماند، به ویژه برای حوادث جدید، تغییرات حساس تولید، یا موقعیت‌هایی که اطمینان مدل پایین است. انسان‌ها مسئول قضاوت و امضای نهایی باقی می‌مانند.</div>
            </div>
        </div>

        <div class="example-box">
            <span class="example-label">مثال</span>
            <p>
                <strong>Virgin Atlantic</strong> از Codex برای تقویت نحوه استقرار و نگهداری سیستم‌های تیم‌ها استفاده می‌کند. افزونه Codex VS Code به مهندسان مکانی واحد برای بررسی لاگ‌ها، ردیابی مسائل در کد و داده‌ها و بررسی تغییرات می‌دهد. با یکپارچه‌سازی این زمینه عملیاتی در داخل IDE، سرعت کشف علت ریشه‌ای افزایش می‌یابد و تریاژ دستی کاهش می‌یابد.
            </p>
        </div>

        <div class="checklist">
            <div class="checklist-title">چک‌لیست شروع کار</div>
            <div class="checklist-item">
                <div class="checkbox-circle"></div>
                <div>اتصال ابزارهای هوش مصنوعی به سیستم‌های لاگینگ و استقرار: ادغام Codex CLI یا مشابه آن با سرورهای MCP و تجمیع‌کنندگان لاگ شما.</div>
            </div>
            <div class="checklist-item">
                <div class="checkbox-circle"></div>
                <div>تعریف دامنه‌های دسترسی و مجوزها: اطمینان حاصل کنید که عامل‌ها می‌توانند به لاگ‌های مرتبط، مخازن کد و تاریخچه استقرار دسترسی داشته باشند در حالی که بهترین شیوه‌های امنیتی را حفظ می‌کنند.</div>
            </div>
            <div class="checklist-item">
                <div class="checkbox-circle"></div>
                <div>پیکربندی قالب‌های پرامپت: ایجاد پرامپت‌های قابل استفاده مجدد برای کوئری‌های عملیاتی رایج، مانند "بررسی خطاها برای Endpoint X".</div>
            </div>
            <div class="checklist-item">
                <div class="checkbox-circle"></div>
                <div>تست گردش‌کار: اجرای سناریوهای حادثه شبیه‌سازی شده برای اطمینان از اینکه هوش مصنوعی زمینه صحیح را نشان می‌دهد و تشخیص‌های عملی پیشنهاد می‌کند.</div>
            </div>
            <div class="checklist-item">
                <div class="checkbox-circle"></div>
                <div>تکرار و بهبود: جمع‌آوری بازخورد از حوادث واقعی، تنظیم استراتژی‌های پرامپت و گسترش قابلیت‌های عامل با تکامل سیستم‌ها.</div>
            </div>
        </div>
    </section>

    <section id="conclusion" style="background-color: #f0fdf4; padding: 40px; border-radius: 12px; border: 1px solid #10a37f; margin-bottom: 50px;">
        <h2>نتیجه‌گیری</h2>
        <p>
            عامل‌های کدنویسی با بر عهده گرفتن کارهای مکانیکی و چندمرحله‌ای که به طور سنتی تیم‌های مهندسی را کند می‌کردند، در حال تغییر چرخه حیات توسعه نرم‌افزار هستند. با استدلال پایدار، زمینه یکپارچه کد، و توانایی اجرای ابزارهای واقعی، این عامل‌ها اکنون وظایفی از محدوده‌بندی و نمونه‌سازی تا پیاده‌سازی، تست، بازبینی و حتی تریاژ عملیاتی را انجام می‌دهند. مهندسان همچنان کنترل معماری، هدف محصول و کیفیت را در دست دارند — اما عامل‌های کدنویسی به طور فزاینده‌ای به عنوان اولین پیاده‌ساز و همکار مداوم در هر مرحله از SDLC عمل می‌کنند.
        </p>
        <p>
            این تغییر نیاز به بازنگری رادیکال ندارد؛ گردش‌کارهای کوچک و هدفمند به سرعت ترکیب می‌شوند زیرا عامل‌های کدنویسی تواناتر و قابل اعتمادتر می‌شوند. تیم‌هایی که با وظایف کاملاً مشخص شروع می‌کنند، در گاردریل‌ها سرمایه‌گذاری می‌کنند و مسئولیت عامل را به تدریج گسترش می‌دهند، دستاوردهای معناداری در سرعت، ثبات و تمرکز توسعه‌دهنده می‌بینند.
        </p>
        <p>
            اگر در حال بررسی چگونگی شتاب بخشیدن عامل‌های کدنویسی به سازمان خود هستید یا برای اولین استقرار خود آماده می‌شوید، با OpenAI تماس بگیرید. ما اینجا هستیم تا به شما کمک کنیم عامل‌های کدنویسی را به اهرم واقعی تبدیل کنید — طراحی گردش‌کارهای پایان-به-پایان در برنامه‌ریزی، طراحی، ساخت، تست، بازبینی و عملیات، و کمک به تیم شما برای اتخاذ الگوهای آماده تولید که مهندسی بومی هوش مصنوعی را به واقعیت تبدیل می‌کند.
        </p>
    </section>

    <footer>
        <p><a href="https://cdn.openai.com/business-guides-and-resources/building-an-ai-native-engineering-team.pdf" target="_blank">Link to Original Article (PDF)</a></p>
        <p>© 2025 OpenAI - Building an AI-native engineering team</p>
        <div class="dev-signature">
            Translated by HexQuant Ai DevBy TheRealPourya
        </div>
    </footer>
</div>

<script>
    
    document.querySelectorAll('.checklist-item').forEach(item => {
        item.addEventListener('click', function() {
            this.classList.toggle('checked');
            const circle = this.querySelector('.checkbox-circle');
            if (this.classList.contains('checked')) {
                circle.innerHTML = '✓';
            } else {
                circle.innerHTML = '';
            }
        });
    });
</script>

</body>
</html>
